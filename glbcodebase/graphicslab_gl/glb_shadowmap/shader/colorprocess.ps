//------------------------------------------------------------
// Declaration: Copyright (c), by i_dovelemon, 2016. All right reserved.
// Author: i_dovelemom[1322600812@qq.com]
// Date: 2016 / 09 / 12
// Brief: Color process will do color correction and color grading
//------------------------------------------------------------

in vec2 glb_ps_tex_coord;
out vec3 glb_color;

uniform sampler2D glb_scene_tex;
uniform sampler3D glb_lut32_tex;

const float glb_gamma = 2.2;
const float glb_lut_size = 16.0;

void main() {
	vec3 src_color = texture2D(glb_scene_tex, glb_ps_tex_coord).xyz;

	// Color correction (aka Gamma correction)
	float gamma = 1.0 / glb_gamma;
	src_color.x = pow(src_color.x, gamma);
	src_color.y = pow(src_color.y, gamma);

	//----------------------------------------------------------------------
	// The z value is a little tricky.
	// If the 3D texture is 16*16*16,
	// then the first slice's z coordinate is defined as 0.5 * 1.0 / 16.0.
	// This means if you don't specific the z coordinate as center the slice,
	// it will sample two nearest slice and blend the result value.
	// For more detail, look at this page:
	// http://stackoverflow.com/questions/31810822/opengl-3d-texture-shine-through
	//----------------------------------------------------------------------
	src_color.z = pow(src_color.z, gamma);
	src_color.z = src_color.z / (1.0 / glb_lut_size);
	src_color.z = floor(src_color.z) * 1.0 / glb_lut_size + 0.5 * 1.0 / glb_lut_size;

	// Color grading
	glb_color = texture3D(glb_lut32_tex, src_color).xyz;
}