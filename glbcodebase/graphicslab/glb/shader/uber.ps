//----------------------------------------------------
// Declaration: Copyright (c), by i_dovelemon, 2016. All right reserved.
// Author: i_dovelemon[1322600812@qq.com]
// Date: 2016 / 10 / 15
// Brief: This is a uber shader, all the light calculation, texture mapping
// and some sort of that will be implemented in this shader.
//----------------------------------------------------
// Input attributes
in vec3 vs_Vertex;

#ifdef GLB_COLOR_IN_VERTEX
in vec3 vs_Color;
#endif

#ifdef GLB_NORMAL_IN_VERTEX
in vec3 vs_Normal;
#endif

#ifdef GLB_TANGENT_IN_VERTEX
in vec3 vs_Tangent;
#endif

#ifdef GLB_BINORMAL_IN_VERTEX
in vec3 vs_Binormal;
#endif

#ifdef GLB_TANGENT_IN_VERTEX
#ifdef GLB_BINORMAL_IN_VERTEX
in vec3 vs_NT;
#endif
#endif

#ifdef GLB_TEXCOORD_IN_VERTEX
in vec2 vs_TexCoord;
#endif

// Output color
out vec4 oColor;

// Uniform
#ifdef GLB_TEXCOORD_IN_VERTEX

	#ifdef GLB_ENABLE_DIFFUSE_TEX
	uniform sampler2D glb_DiffuseTex;
	#endif

	#ifdef GLB_ENABLE_ALPHA_TEX
	uniform sampler2D glb_AlphaTex;
	#endif

	#ifdef GLB_ENABLE_NORMAL_TEX
	uniform sampler2D glb_NormalTex;

		#ifdef GLB_TANGENT_IN_VERTEX
		#ifdef GLB_BINORMAL_IN_VERTEX
			#define GLB_ENABLE_NORMAL_MAPPING
		#endif
		#endif
	#endif

	#ifdef GLB_ENABLE_REFLECT_TEX
		uniform samplerCube glb_ReflectTex;
	#endif

#endif

#ifdef GLB_ENABLE_SHADOW
uniform sampler2D glb_ShadowTex;
uniform mat4 glb_ShadowM;
#endif

#ifdef GLB_ENABLE_AO
uniform float glb_ScreenWidth;
uniform float glb_ScreenHeight;
uniform sampler2D glb_AOMap;
#endif

#ifdef GLB_ENABLE_LIGHTING
	#define GLB_ENABLE_EYE_POS
#endif

#ifdef GLB_ENABLE_REFLECT_TEX
	#define GLB_ENABLE_EYE_POS
#endif

#ifdef GLB_ENABLE_EYE_POS
uniform vec3 glb_EyePos;
#endif

#ifdef GLB_ENABLE_LIGHTING
uniform vec3 glb_Material_Ambient;
uniform vec3 glb_Material_Diffuse;
uniform vec3 glb_Material_Specular;
uniform vec3 glb_Material_Emission;
uniform float glb_Material_Pow;

	#ifdef GLB_USE_PARALLEL_LIGHT
	uniform vec3 glb_ParallelLight_Dir;
	uniform vec3 glb_ParallelLight_Ambient;
	uniform vec3 glb_ParallelLight_Diffuse;
	uniform vec3 glb_ParallelLight_Specular;

	vec3 calc_diffuse(vec3 light_vec, vec3 normal, vec3 light_color) {
		float ratio = dot(light_vec, normal);
		ratio = max(ratio, 0.0);
		return light_color * ratio;
	}

	vec3 calc_specular(vec3 light_vec, vec3 normal, vec3 view_vec, vec3 light_color, float pow_value) {
		/*******************************************
		* reflect(incident light vector, surface normal)
		* incident_light_vec = -light_vec
		********************************************/
		vec3 ref_light_vec = reflect(-light_vec, normal);
		float ratio = dot(ref_light_vec, view_vec);
		ratio = max(ratio, 0.0);
		ratio = pow(ratio, pow_value);

		return light_color * ratio;
	}
	#else
		#error No light source specified
	#endif

#endif  // GLB_ENABLE_LIGHTING

void main() {
	oColor = vec4(0.0, 0.0, 0.0, 1.0);

	vec3 diffuse_light = vec3(0.0, 0.0, 0.0);
	vec3 specular_light = vec3(0.0, 0.0, 0.0);
	vec3 ambient_light = vec3(0.0, 0.0, 0.0);
	vec3 reflect_light = vec3(0.0, 0.0, 0.0);

	float is_in_shadow = 0.0;
#ifdef GLB_ENABLE_SHADOW
	vec4 light_space_pos = glb_ShadowM * vec4(vs_Vertex, 1.0);
	light_space_pos.xyz /= 2.0f;
	light_space_pos.xyz += 0.5f;
	light_space_pos.xyz /= light_space_pos.w;
	float factor = texture2D(glb_ShadowTex, light_space_pos.xy).z;
	if (factor < light_space_pos.z) {
		is_in_shadow = 1.0;
	}
#endif

	vec3 normal = vec3(0.0, 0.0, 0.0);
#ifdef GLB_NORMAL_IN_VERTEX
	normal = normalize(vs_Normal);
#endif

#ifdef GLB_ENABLE_NORMAL_MAPPING
	normal = texture2D(glb_NormalTex, vs_TexCoord).xyz;
	normal -= vec3(0.5, 0.5, 0.5);
	normal *= 2.0;

	mat3 tbn = mat3(vs_Tangent, vs_Binormal, vs_NT);
	normal = tbn * normal;
	normalize(normal);
#endif

#ifdef GLB_ENABLE_EYE_POS
	vec3 view_vec = normalize(glb_EyePos - vs_Vertex);
#endif	

#ifdef GLB_ENABLE_LIGHTING
	if (is_in_shadow <= 0.0) {
		#ifdef GLB_USE_PARALLEL_LIGHT
			vec3 light_vec = -glb_ParallelLight_Dir;
			ambient_light = glb_ParallelLight_Ambient;
			diffuse_light = calc_diffuse(light_vec, normal, glb_ParallelLight_Diffuse);
			specular_light = calc_specular(light_vec, normal, view_vec, glb_ParallelLight_Specular, glb_Material_Pow);
		#endif
	} else {
		ambient_light = glb_ParallelLight_Ambient;	
	}
#else
	if (is_in_shadow >= 1.0) {
		oColor.xyz = 0.5 * oColor.xyz;
	}
#endif

#ifdef GLB_ENABLE_AO
	vec2 ao_coord = vec2(gl_FragCoord.x / glb_ScreenWidth, gl_FragCoord.y / glb_ScreenHeight);
	ambient_light *= texture2D(glb_AOMap, ao_coord).rgb;
#endif

	vec3 light = ambient_light + specular_light + diffuse_light;

#ifdef GLB_ENABLE_REFLECT_TEX
	vec3 refl = reflect(-view_vec, normal);
	refl = normalize(refl);
	refl.yz = -refl.yz;
	reflect_light = textureCube(glb_ReflectTex, refl).xyz;
#endif

	vec3 ambient_brdf = vec3(0.0, 0.0, 0.0);
	vec3 diffuse_brdf = vec3(0.0, 0.0, 0.0);
	vec3 specular_brdf = vec3(0.0, 0.0, 0.0);
#ifdef GLB_TEXCOORD_IN_VERTEX
	#ifdef GLB_ENABLE_DIFFUSE_TEX
		diffuse_brdf.xyz += texture2D(glb_DiffuseTex, vs_TexCoord).xyz;
	#endif
#endif

#ifdef GLB_COLOR_IN_VERTEX
	diffuse_brdf.xyz += vs_Color;
#endif

#ifdef GLB_ENABLE_LIGHTING
	ambient_brdf += glb_Material_Ambient;
	diffuse_brdf += glb_Material_Diffuse;
	specular_brdf += glb_Material_Specular;
#endif

#ifdef GLB_ENABLE_LIGHTING
	/*******************************************
	* For now, we just add reflect light to diffuse light
	********************************************/	
	oColor.xyz = (ambient_light * ambient_brdf) + (diffuse_light + reflect_light) * diffuse_brdf + (specular_light * specular_brdf);
#else
	/*******************************************
	* For now, if the object do not enable light,
	* we just sum all color that we can use
	********************************************/	
	oColor.xyz += diffuse_brdf.xyz;

	#ifdef GLB_ENABLE_REFLECT_TEX
		oColor.xyz += reflect_light;
	#endif
#endif

#ifdef GLB_TEXCOORD_IN_VERTEX
	#ifdef GLB_ENABLE_ALPHA_TEX
		oColor.w = texture2D(glb_AlphaTex, vs_TexCoord).w;
	#endif
#endif
}